(function(){
  // #KGNINJA - Non-module fallback bundle for file:// usage
  // Minimal console markers
  try { console.log('bundle v2 start'); } catch (e) {}

  // types.js
  const Direction = { Up:0, Right:1, Down:2, Left:3 };

  // engine.js
  function makeRng(seed = 123456789) { let s = seed >>> 0; return { seed, next(){ s = (1664525 * s + 1013904223) >>> 0; return (s & 0xffffffff) / 0x100000000; } }; }
  function dirVec(d){ switch(d){ case Direction.Up:return [0,-1]; case Direction.Right:return [1,0]; case Direction.Down:return [0,1]; case Direction.Left:return [-1,0]; }}
  function rotLeft(d){ return ((d+3)&3); } function rotRight(d){ return ((d+1)&3); }
  function inBounds(st,x,y){ return x>=0&&y>=0&&x<st.width&&y<st.height; }
  function tileAt(st,x,y){ if(!inBounds(st,x,y)) return null; return st.grid[y][x]; }
  function tankAt(st,x,y){ for(const t of st.tanks) if(t.hp>0&&t.x===x&&t.y===y) return t; return null; }
  function makeMap(width=16,height=16){ const g=[]; for(let y=0;y<height;y++){ const row=[]; for(let x=0;x<width;x++){ const border = x===0||y===0||x===width-1||y===height-1; row.push(border?'wall':'empty'); } g.push(row);} const walls=[[5,5],[5,6],[5,7],[10,8],[10,9],[10,10],[8,3],[9,3]]; for(const [wx,wy] of walls) g[wy][wx]='wall'; return g; }
  function initialState(){ const grid=makeMap(); const t0={id:0,x:2,y:2,dir:Direction.Right,hp:5,cooldown:0}; const t1={id:1,x:13,y:13,dir:Direction.Left,hp:5,cooldown:0}; return { width:16,height:16,grid,tanks:[t0,t1],bullets:[],tick:0,status:'playing',winner:null }; }
  function senseFor(st,tank){ const [dx,dy]=dirVec(tank.dir); const nx=tank.x+dx, ny=tank.y+dy; const aheadTile=tileAt(st,nx,ny); const wallAhead=aheadTile!=='empty'; let x=tank.x+dx,y=tank.y+dy, enemyAhead=false; while(inBounds(st,x,y)){ const tile=tileAt(st,x,y); if(tile==='wall') break; const enemy=st.tanks.find(t=>t.hp>0&&t.id!==tank.id&&t.x===x&&t.y===y); if(enemy){ enemyAhead=true; break; } x+=dx; y+=dy; } return { enemyAhead, wallAhead }; }
  function toView(st,id){ const t=st.tanks[id]; const sense=senseFor(st,t); return { id:t.id,x:t.x,y:t.y,dir:t.dir,hp:t.hp,tick:st.tick,sense }; }
  function applyMovement(st,intents){ const targets=new Map(); for(const t of st.tanks){ if(t.hp<=0) continue; const act=intents.get(t.id); if(act==='MOVE'){ const [dx,dy]=dirVec(t.dir); targets.set(t.id,{x:t.x+dx,y:t.y+dy}); } }
    for(const t of st.tanks){ if(t.hp<=0) continue; const act=intents.get(t.id); if(act==='TURN_LEFT') t.dir=rotLeft(t.dir); else if(act==='TURN_RIGHT') t.dir=rotRight(t.dir); }
    for(const t of st.tanks){ if(t.hp<=0) continue; const tgt=targets.get(t.id); if(!tgt) continue; const blocked=!inBounds(st,tgt.x,tgt.y)||tileAt(st,tgt.x,tgt.y)!=='empty'||tankAt(st,tgt.x,tgt.y); const conflict=[...targets.entries()].some(([oid,o])=>oid!==t.id&&o.x===tgt.x&&o.y===tgt.y); if(!blocked && !conflict){ t.x=tgt.x; t.y=tgt.y; } }
  }
  function applyFire(st,intents){ for(const t of st.tanks){ if(t.hp<=0) continue; if(t.cooldown>0) continue; if(intents.get(t.id)==='FIRE'){ const [dx,dy]=dirVec(t.dir); const bx=t.x+dx, by=t.y+dy; if(inBounds(st,bx,by)&&tileAt(st,bx,by)==='empty'&&!tankAt(st,bx,by)){ st.bullets.push({x:bx,y:by,dir:t.dir}); t.cooldown=2; } else { const enemy=st.tanks.find(o=>o.hp>0&&o.id!==t.id&&o.x===bx&&o.y===by); if(enemy) enemy.hp-=1; t.cooldown=2; } } } }
  function updateBullets(st){ const next=[]; for(const b of st.bullets){ const [dx,dy]=dirVec(b.dir); let nx=b.x+dx, ny=b.y+dy, alive=true; if(!inBounds(st,nx,ny)) alive=false; else if(tileAt(st,nx,ny)!=='empty') alive=false; else { const hit=st.tanks.find(t=>t.hp>0&&t.x===nx&&t.y===ny); if(hit){ hit.hp-=1; alive=false; } } if(alive) next.push({x:nx,y:ny,dir:b.dir}); } st.bullets=next; }
  function updateCooldowns(st){ for(const t of st.tanks) if(t.cooldown>0) t.cooldown-=1; }
  function step(st,ctrls,rng){ if(st.status!=='playing') return st; const intents=new Map(); for(const t of st.tanks){ if(t.hp<=0) continue; const ctrl=ctrls[t.id]; const action=ctrl(toView(st,t.id), ()=>rng.next()); intents.set(t.id, action); } applyMovement(st,intents); applyFire(st,intents); updateBullets(st); updateCooldowns(st); st.tick+=1; const alive=st.tanks.filter(t=>t.hp>0); if(alive.length<=1){ st.status='gameover'; st.winner= alive.length===1? alive[0].id : null; } if(st.tick>=1000 && st.status==='playing'){ st.status='gameover'; st.winner=null; } return st; }

  // ai.js
  function compileCondition(expr){ const e=(expr||'').trim().toLowerCase(); if(e==='enemy_ahead') return v=>v.sense.enemyAhead; if(e==='wall_ahead') return v=>v.sense.wallAhead; if(e==='always'||e==='else') return ()=>true; if(e.startsWith('random<')){ const p=Number(e.slice('random<'.length)); const prob=isFinite(p)? Math.max(0,Math.min(1,p)) : 0; return (_,rnd)=> rnd()<prob; } return ()=>false; }
  function compileRule(r){ return { test: compileCondition(r.if), action: r.do }; }
  function compileProgram(prog){ const rules=(prog.rules||[]).map(compileRule); return (view,rnd)=>{ for(const r of rules) if(r.test(view,rnd)) return r.action; return 'WAIT'; }; }
  function parseProgram(text){ const obj=JSON.parse(text); if(!obj||typeof obj!=='object') throw new Error('Invalid program: not an object'); if(!Array.isArray(obj.rules)) throw new Error('Invalid program: missing rules[]'); for(const [i,r] of obj.rules.entries()){ if(!r||typeof r!=='object') throw new Error(`Rule ${i}: not an object`); if(typeof r.if!=='string') throw new Error(`Rule ${i}: missing if`); if(typeof r.do!=='string') throw new Error(`Rule ${i}: missing do`); } return obj; }
  const DEFAULT_AI_1 = { name:'Seeker', rules:[ {if:'enemy_ahead',do:'FIRE'}, {if:'wall_ahead',do:'TURN_RIGHT'}, {if:'random<0.1',do:'TURN_LEFT'}, {if:'else',do:'MOVE'} ] };
  const DEFAULT_AI_2 = { name:'Wanderer', rules:[ {if:'enemy_ahead',do:'FIRE'}, {if:'wall_ahead',do:'TURN_LEFT'}, {if:'random<0.2',do:'TURN_RIGHT'}, {if:'else',do:'MOVE'} ] };

  // render.js
  class Renderer { constructor(canvas,opts){ const ctx=canvas.getContext('2d'); if(!ctx) throw new Error('Canvas 2D not available'); this.canvas=canvas; this.ctx=ctx; this.opts=Object.assign({cell:32}, opts||{}); }
    clear(){ const {ctx,canvas}=this; ctx.clearRect(0,0,canvas.width,canvas.height); }
    drawGrid(w,h){ const {ctx}=this; const s=this.opts.cell; ctx.strokeStyle='#1f2448'; ctx.lineWidth=1; for(let x=0;x<=w;x++){ ctx.beginPath(); ctx.moveTo(x*s,0); ctx.lineTo(x*s,h*s); ctx.stroke(); } for(let y=0;y<=h;y++){ ctx.beginPath(); ctx.moveTo(0,y*s); ctx.lineTo(w*s,y*s); ctx.stroke(); } }
    drawTiles(grid){ const {ctx}=this; const s=this.opts.cell; for(let y=0;y<grid.length;y++){ for(let x=0;x<grid[0].length;x++){ if(grid[y][x]==='wall'){ ctx.fillStyle='#2a305f'; ctx.fillRect(x*s,y*s,s,s); } } } }
    drawTank(x,y,dir,color){ const {ctx}=this; const s=this.opts.cell; const cx=x*s+s/2, cy=y*s+s/2; const r=s*0.42; const angle=angleForDir(dir); const p0=[cx+Math.cos(angle)*r, cy+Math.sin(angle)*r]; const p1=[cx+Math.cos(angle+2.5)*r, cy+Math.sin(angle+2.5)*r]; const p2=[cx+Math.cos(angle-2.5)*r, cy+Math.sin(angle-2.5)*r]; ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(p0[0],p0[1]); ctx.lineTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.closePath(); ctx.fill(); const [dx,dy]=dirVec(dir); ctx.strokeStyle='#e0e6ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+dx*r, cy+dy*r); ctx.stroke(); }
    drawBullets(bullets){ const {ctx}=this; const s=this.opts.cell; ctx.fillStyle='#fdd835'; for(const b of bullets) ctx.fillRect(b.x*s+s*0.35, b.y*s+s*0.35, s*0.3, s*0.3); }
    drawInterpolated(st, prev, alpha, effects){ const {ctx}=this; const s=this.opts.cell; this.clear(); this.drawTiles(st.grid); this.drawGrid(st.width, st.height); const colors=['#ef5350','#26c6da'];
      for(const t of st.tanks){ if(t.hp<=0) continue; if(prev&&prev.tanks){ const pt = prev.tanks.find(p=>p.id===t.id) || t; const moved = (pt.x!==t.x)||(pt.y!==t.y); const x = moved? lerp(pt.x,t.x,alpha):t.x; const y = moved? lerp(pt.y,t.y,alpha):t.y; const pa=angleForDir(pt.dir), ca=angleForDir(t.dir); let d=ca-pa; while(d>Math.PI) d-=Math.PI*2; while(d<-Math.PI) d+=Math.PI*2; const ang=pa + d*alpha; const cx=x*s+s/2, cy=y*s+s/2; const r=s*0.42; const p0=[cx+Math.cos(ang)*r, cy+Math.sin(ang)*r]; const p1=[cx+Math.cos(ang+2.5)*r, cy+Math.sin(ang+2.5)*r]; const p2=[cx+Math.cos(ang-2.5)*r, cy+Math.sin(ang-2.5)*r]; ctx.fillStyle=colors[t.id]||'#90caf9'; ctx.beginPath(); ctx.moveTo(p0[0],p0[1]); ctx.lineTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.closePath(); ctx.fill(); const [dx,dy]=dirVec(t.dir); ctx.strokeStyle='#e0e6ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+dx*r, cy+dy*r); ctx.stroke(); } else { this.drawTank(t.x,t.y,t.dir,colors[t.id]||'#90caf9'); } }
      ctx.fillStyle='#fdd835'; for(const b of st.bullets){ const [dx,dy]=dirVec(b.dir); const fx=b.x - dx*(1-alpha); const fy=b.y - dy*(1-alpha); ctx.fillRect(fx*s+s*0.35, fy*s+s*0.35, s*0.3, s*0.3); }
      if(effects&&effects.length){ const now=performance.now(); for(const e of effects){ const t=(now - e.start)/e.life; const clamped=Math.max(0,Math.min(1,t)); if(e.type==='muzzle'){ const cx=e.x*s+s/2, cy=e.y*s+s/2; const r=s*(0.2+0.2*(1-clamped)); const ang=angleForDir(e.dir); const p0=[cx+Math.cos(ang)*r*1.8, cy+Math.sin(ang)*r*1.8]; const p1=[cx+Math.cos(ang+2.8)*r, cy+Math.sin(ang+2.8)*r]; const p2=[cx+Math.cos(ang-2.8)*r, cy+Math.sin(ang-2.8)*r]; ctx.fillStyle=`rgba(255,220,120,${1-clamped})`; ctx.beginPath(); ctx.moveTo(p0[0],p0[1]); ctx.lineTo(p1[0],p1[1]); ctx.lineTo(p2[0],p2[1]); ctx.closePath(); ctx.fill(); } else if(e.type==='explosion'){ const cx=e.x*s+s/2, cy=e.y*s+s/2; const R=s*(0.3+0.4*clamped); ctx.save(); ctx.translate(cx,cy); ctx.fillStyle=`rgba(255,150,80,${1-clamped})`; ctx.beginPath(); const spikes=8; const inner=R*0.5; for(let i=0;i<spikes*2;i++){ const rr=(i%2===0)?R:inner; const ang=(i/(spikes*2))*Math.PI*2; const px=Math.cos(ang)*rr, py=Math.sin(ang)*rr; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.closePath(); ctx.fill(); ctx.restore(); } } }
      ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='bold 18px ui-monospace, monospace'; ctx.fillText(`Tick ${st.tick}`,8,22);
    }
    draw(st, prev, alpha, effects){ this.drawInterpolated(st, prev, alpha??1, effects); }
  }

  // render3d.js (embedded)
  class Renderer3D { constructor(canvas,opts){ const ctx=canvas.getContext('2d'); if(!ctx) throw new Error('Canvas 2D not available'); this.canvas=canvas; this.ctx=ctx; this.opts=Object.assign({cell:16, originX: canvas.width/2, originY: 80}, opts||{});} iso(x,y,z){ const s=this.opts.cell; return [ this.opts.originX + (x-y)*s, this.opts.originY + (x+y)*s*0.5 - z ]; } poly(pts,fill,stroke){ const {ctx}=this; ctx.beginPath(); ctx.moveTo(pts[0][0],pts[0][1]); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]); ctx.closePath(); if(fill){ ctx.fillStyle=fill; ctx.fill(); } if(stroke){ ctx.strokeStyle=stroke; ctx.stroke(); } } clear(){ const {ctx,canvas}=this; ctx.clearRect(0,0,canvas.width,canvas.height);} drawFloor(st){ const {ctx}=this; const s=this.opts.cell; ctx.strokeStyle='rgba(120,140,200,0.15)'; ctx.lineWidth=1; for(let x=0;x<=st.width;x++){ const a=this.iso(x,0,0), b=this.iso(x,st.height,0); ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); } for(let y=0;y<=st.height;y++){ const a=this.iso(0,y,0), b=this.iso(st.width,y,0); ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); } } drawWalls(st){ const h=this.opts.cell*0.9; for(let y=0;y<st.height;y++){ for(let x=0;x<st.width;x++){ if(st.grid[y][x]!=='wall') continue; const top=[ this.iso(x,y,h), this.iso(x+1,y,h), this.iso(x+1,y+1,h), this.iso(x,y+1,h) ]; const left=[ this.iso(x,y,0), this.iso(x,y,h), this.iso(x,y+1,h), this.iso(x,y+1,0) ]; const right=[ this.iso(x+1,y,0), this.iso(x+1,y,h), this.iso(x+1,y+1,h), this.iso(x+1,y+1,0) ]; this.poly(right,'#313a79'); this.poly(left,'#262f61'); this.poly(top,'#48519a'); } } } drawTank(t,prev,alpha,color){ const h=this.opts.cell*0.8; const cx=t.x+0.5, cy=t.y+0.5; const pdir=prev?prev.dir:t.dir; const pa=[-Math.PI/2,0,Math.PI/2,Math.PI][pdir]; const ca=[-Math.PI/2,0,Math.PI/2,Math.PI][t.dir]; let da=ca-pa; while(da>Math.PI) da-=Math.PI*2; while(da<-Math.PI) da+=Math.PI*2; const ang=pa + da*alpha; const r=0.45; const p0=[cx+Math.cos(ang)*r, cy+Math.sin(ang)*r]; const p1=[cx+Math.cos(ang+2.5)*r, cy+Math.sin(ang+2.5)*r]; const p2=[cx+Math.cos(ang-2.5)*r, cy+Math.sin(ang-2.5)*r]; const top=[ this.iso(p0[0],p0[1],h), this.iso(p1[0],p1[1],h), this.iso(p2[0],p2[1],h) ]; this.poly(top,color); const sh=[ this.iso(p0[0],p0[1],0), this.iso(p1[0],p1[1],0), this.iso(p2[0],p2[1],0) ]; this.poly(sh,'rgba(0,0,0,0.15)'); } drawBullets(st,alpha){ const s=this.opts.cell; const r=s*0.15; const {ctx}=this; ctx.fillStyle='#ffd54f'; for(const b of st.bullets){ const v=b.dir===0?[0,-1]:b.dir===1?[1,0]:b.dir===2?[0,1]:[-1,0]; const fx=b.x - v[0]*(1-alpha) + 0.5; const fy=b.y - v[1]*(1-alpha) + 0.5; const p=this.iso(fx,fy,s*0.4); ctx.beginPath(); ctx.moveTo(p[0],p[1]-r); ctx.lineTo(p[0]+r,p[1]); ctx.lineTo(p[0],p[1]+r); ctx.lineTo(p[0]-r,p[1]); ctx.closePath(); ctx.fill(); } } drawEffects(effects){ const {ctx}=this; for(const e of effects){ const now=performance.now(); const t=Math.max(0,Math.min(1,(now-e.start)/e.life)); if(e.type==='explosion'){ const p=this.iso(e.x+0.5,e.y+0.5,this.opts.cell*0.4); const R=this.opts.cell*(0.1+0.25*t); ctx.fillStyle=`rgba(255,120,60,${1-t})`; ctx.beginPath(); for(let i=0;i<8;i++){ const a=(i/8)*Math.PI*2; const rr=i%2===0?R:R*0.5; const x=p[0]+Math.cos(a)*rr, y=p[1]+Math.sin(a)*rr; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);} ctx.closePath(); ctx.fill(); } } } draw(st,prev,alpha,effects){ this.clear(); this.drawFloor(st); this.drawWalls(st); const colors=['#ef5350','#26c6da']; for(const t of st.tanks){ if(t.hp<=0) continue; const pt=prev&&prev.tanks? prev.tanks.find(p=>p.id===t.id):null; this.drawTank(t,pt,alpha??1,colors[t.id]||'#90caf9'); } this.drawBullets(st,alpha??1); if(effects&&effects.length) this.drawEffects(effects); }

  // main.js
  function gid(id){ return document.getElementById(id); }
  let state, rng, renderer, renderer3d, controllers=[], timer=null;
  const tickMs = 480; let lastTickTime = performance.now(); // slowed to 1/3 speed
  let prevState = null; let effects = [];
  function snapshot(st){ return { tanks: st.tanks.map(t=>({id:t.id,x:t.x,y:t.y,dir:t.dir,hp:t.hp})), bullets: st.bullets.map(b=>({x:b.x,y:b.y,dir:b.dir})) }; }
  function setupRenderer(){ const canvas=gid('game'); renderer = new Renderer(canvas, {cell:32}); const canvas3d=gid('game3d'); if(canvas3d){ try { renderer3d = new Renderer3D(canvas3d, {cell:16}); } catch(e){} } }
  function setEditors(p1,p2){ gid('ai1').value = JSON.stringify(p1,null,2); gid('ai2').value = JSON.stringify(p2,null,2); }
  function compileFromEditors(){ const p1=parseProgram(gid('ai1').value); const p2=parseProgram(gid('ai2').value); return [compileProgram(p1), compileProgram(p2)]; }
  function updateStatus(){ gid('stats').textContent = `Tick: ${state.tick} | HP: Red ${state.tanks[0].hp} vs Cyan ${state.tanks[1].hp}`; const status=gid('status'); status.textContent = state.status==='gameover' ? (state.winner!=null ? `Game Over — Winner: ${state.winner===0?'Red':'Cyan'}` : 'Game Over — Draw') : 'Playing'; }
  function render(){ updateStatus(); }
  function doStep(){ try{ console.log('tick before', state.tick); prevState = snapshot(state); state = step(state, controllers, rng); lastTickTime = performance.now();
      const prevSet = new Set(prevState.bullets.map(b=>`${b.x},${b.y},${b.dir}`)); const currSet = new Set(state.bullets.map(b=>`${b.x},${b.y},${b.dir}`));
      for(const b of state.bullets){ const v = b.dir===0?[0,-1]:b.dir===1?[1,0]:b.dir===2?[0,1]:[-1,0]; const keyPrev = `${b.x - v[0]},${b.y - v[1]},${b.dir}`; if(!prevSet.has(keyPrev)) effects.push({type:'muzzle', x:b.x - v[0]*0.5, y:b.y - v[1]*0.5, dir:b.dir, start: performance.now(), life:150}); }
      for(const pb of prevState.bullets){ const v = pb.dir===0?[0,-1]:pb.dir===1?[1,0]:pb.dir===2?[0,1]:[-1,0]; const nx=pb.x+v[0], ny=pb.y+v[1]; const keyNext = `${nx},${ny},${pb.dir}`; if(!currSet.has(keyNext)) effects.push({type:'explosion', x:nx, y:ny, start: performance.now(), life:300}); }
      render(); console.log('tick after', state.tick); if(state.status==='gameover' && timer!=null) stop(); } catch(err){ const box=gid('error'); if(box) box.textContent = 'Runtime error: ' + (err&&err.message?err.message:String(err)); console.error(err); stop(); } }
  function play(){ if(timer!=null) return; gid('btn-play').disabled=true; gid('btn-pause').disabled=false; console.log('start interval'); timer = window.setInterval(doStep, tickMs); doStep(); }
  function stop(){ if(timer!=null){ window.clearInterval(timer); timer=null; } gid('btn-play').disabled=false; gid('btn-pause').disabled=true; }
  function reset(){ stop(); state = initialState(); rng = makeRng(1234); render(); }
  function applyAI(){ try{ controllers = compileFromEditors(); reset(); var ap = document.getElementById('auto-play'); if (ap && ap.checked) play(); } catch(e){ const box=gid('error'); if(box) box.textContent = e && e.message ? e.message : String(e); } }
  function wireUI(){ console.log('bind play'); gid('btn-play').addEventListener('click', ()=>{ console.log('click play'); play(); }); console.log('bind pause'); gid('btn-pause').addEventListener('click', ()=>{ console.log('click pause'); stop(); }); console.log('bind step'); gid('btn-step').addEventListener('click', ()=>{ console.log('click step'); doStep(); }); console.log('bind reset'); gid('btn-reset').addEventListener('click', ()=>{ console.log('click reset'); reset(); }); console.log('bind apply'); gid('btn-apply').addEventListener('click', ()=>{ console.log('click apply'); applyAI(); }); const testBtn=gid('btn-test'); if(testBtn){ console.log('bind test'); testBtn.addEventListener('click', ()=>{ console.log('click test'); for(let i=0;i<10;i++) doStep(); }); } }
  function animate(){ const now=performance.now(); effects = effects.filter(e => (now - e.start) < e.life); const alpha=Math.max(0,Math.min(1,(now - lastTickTime)/tickMs)); try{ renderer.draw(state, prevState, alpha, effects); } catch { renderer.draw(state); } if(renderer3d){ try { renderer3d.draw(state, prevState, alpha, effects); } catch{} } requestAnimationFrame(animate); }
  function main(){ state=initialState(); rng=makeRng(1234); setupRenderer(); setEditors(DEFAULT_AI_1, DEFAULT_AI_2); controllers=compileFromEditors(); prevState = snapshot(state); render(); wireUI(); requestAnimationFrame(animate); }
  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', main);
  } else {
    // If fallback is injected after DOMContentLoaded, run immediately
    try { main(); } catch (e) { console.error('fallback main error', e); }
  }
  window.addEventListener('keydown', (e)=>{ const k=e.key.toLowerCase(); if(k===' '){ e.preventDefault(); if(timer==null){ console.log('key play'); play(); } else { console.log('key pause'); stop(); } } else if(k==='s'){ console.log('key step'); doStep(); } else if(k==='r'){ console.log('key reset'); reset(); } else if(k==='a'){ console.log('key apply'); applyAI(); } });

  try { console.log('bundle ready'); } catch {}
})();
